#:_____________________________________________________
#  confy  |  Copyright (C) Ivan Mar (sOkam!)  |  MIT  |
#:_____________________________________________________
# Code File generation  |
#_______________________|
# std dependencies
import std/os except `/`
import std/paths
import std/strformat
import std/strutils
import std/enumutils
# confy dependencies
import ../../types
# import ../../cfg
import ../../tool/logger
import ./parse


#___________________
const Separator = "\n\n\n"  ## Separator format used between entries.
const Footer    = "\n"      ## Footer added to the resulting file.
const Header    = """
#________________________________
# AutoGenerated | Make-to-Confy  |
#_________________________________________________________________________________
# This file is generated by the makefile-to-confy converter.                     |
# The tool parses the output of the pretend command `make keyword -n`,           |
# and generates the structure of this file.                                      |
# `echo`, `mkdir` and `rm` commands are completely ignored.                      |
# Files are listed explicitely, even if the makefile includes them from a glob.  |
#________________________________________________________________________________|
# std dependencies
from std/os import `/`
# confy dependencies
import confy
"""
const CodeTemplate = """
#_______________________________________
# {trgName}: Setup
#_____________________________
let {trgName}Bin  = "{trg.trg.string}"
let {trgName}Root = "{trg.root.string}"
let {trgName}Src  = {trgSrc}
var {trgName}Trg  = {trg.kind}.new(
  src   = {trgName}Src,
  trg   = {trgName}Bin,
  cc    = {$trg.cc},
  flags = Flags(
    cc: {trgCFlags}
    ld: {trgLFlags}
  root = {trgName}Root,
  syst = System(os: OS.{trg.syst.os.symbolName}, cpu: CPU.{trg.syst.cpu.symbolName}),
  ) # << {trgName}.new({trg.kind}, ... )
#_____________________________
# {trgName}: Task
{trgName&"Trg"}.build()
#___________________
"""
#___________________
proc toFormat (list :seq[Path | string]; name,field :string; level :SomeInteger= 1) :string=
  ## Returns a formatted string for the given list of src files.
  var tab :string
  for lvl in 0..<level: tab.add "  "
  result.add $"@[\n" & tab
  for file in list:
    if file.string == "": continue
    result.add &"\"{file.string}\",\n{tab}"
  result.add &"] # << {name}.{field}( ... )\n"


#___________________
proc toCode *(trg :BuildTrg; name :string) :string=
  ## Returns the code string entry for a single BuildTrg object.
  let trgName   = name
  var trgSrc    = trg.src.toFormat(name,"src", 1)
  var trgCFlags = trg.flags.cc.toFormat(name,"Flags.cc", 3)
  var trgLFlags = trg.flags.ld.toFormat(name,"Flags.ld", 3)
  result = fmt( CodeTemplate )
  result = result.replace( &"\"build{os.DirSep}", &"binDir/\"" )
  result = result.replace( &"\"code{os.DirSep}",  &"srcDir/\"" )

#___________________
proc toFile *(trg :BuildTrg; file :Fil; name :string) :void=
  ## Writes the formatted code string of the input BuildTrg object into the given file path.
  log &"Writing code from `{name}` into `{file.string}` ..."
  file.writeFile( Header & Separator & trg.toCode(name) & Footer )
#___________________
proc toFile *(trgs :seq[BuildTrg]; file :Fil; name :string) :void=
  ## Writes the formatted code string of the input list of BuildTrg objects into the given file path.
  log &"Writing code from `{name}` into `{file.string}` ..."
  var code = Header
  for id,trg in trgs.pairs:
    code &= Separator & trg.toCode( name & &"{id:002}" )
  code &= Footer
  file.writeFile( code )

